# fsm-gen-tool

* Provided a XML file where all the FSM states and transitions are defined, this tool will read that and generate C++ code.
* It will generate the FSM base classes, application code should inherit those and override the methods, which allows developer to concentrate on application's logic.
* Supports very intuitive APIs (fromState->action->toState) to manage the finite state machine
* Each transition will be logged with timestamp and other details for quick & easy debugging
* On demand reporting of FSM transition history in the chronological order
* Validate the input XML file against a schema
* Multiple FSM object can be created and managed simultaneously

## XML file structure
* Please take a look at 'xml/process_state.xml', at the top level everything comes under the 'fsm' tag. Then comes FSM name, list of states, list of actions. 
```sh
    <name>process_state</name>  // name of the FSM object
    <initstate>NEW</initstate>  // initial state

    // list of FSM states 
    <states>
      <state>NEW</state>
      <state>READY</state>
      ...
    </states>

    // list of FSM actions
    <actions>
      <action>SCHEDULAR_DISPATCH</action>
      <action>INTERRUPT</action>
      <action>IO_WAIT</action>
      ...
    </actions>
```
* Under the 'transitions' tag all the transitions are listed. FromState -> Action -> ToState
```sh
 <trans fstate="NEW"               action="ADMITTED"               tstate="READY"/>
``` 
## How to Use:

*  Clone the repo.
```sh
    git clone https://github.com/procoder002/fsm-gen-tool.git
```

* Run configure script which will first generate the 'fsm_gen' binary under generator/build directory
```sh
    chmod +x configure
    ./configure
```
* This 'fsm_gen' takes XML files as input and generate .h and .cpp file under 'autogen' directory which contains pure virtual base classes
```sh
    ./generator/build/fsm_gen   xml/process_state.xml

    autogen/process_state.cpp  autogen/process_state.h
```
* Client code will use this c++ files, inherit from the base class and write their own logic.
  
```sh
    // base class : autogenerated code
    class process_stateFSMBase: public FSM {
      public: 
        virtual void trans_READY_SCHEDULAR_DISPATCH_RUNNING();
        ...
    };

    // derived class: application code
    class appState : public process_stateFSMBase {
      public:
        void trans_READY_SCHEDULAR_DISPATCH_RUNNING() {
            cout << "app trans_READY_SCHEDULAR_DISPATCH_RUNNING" << endl;
            // application logic
        }
    };
```
* Create a application FSM object and move the fsm using the following API,
```sh
    appState app_state("app");  // passing FSM object id as argument, which can be used tracking later
    app_state.performAction(process_stateFSMAction::ADMITTED);
    app_state.performAction(process_stateFSMAction::SCHEDULAR_DISPATCH);
```
* this code will result in the following transition logged here,
```sh
2025-05-12T19:35:01  [app] FSM Transition  NEW->ADMITTED->READY
2025-05-12T19:35:13  [app] FSM Transition  READY->SCHEDULAR_DISPATCH->RUNNING
```

* If application invokes any action that is not defined in the XML, then it will cause invalid transition
```sh
  2025-05-12T19:35:13  [app] INVALID Transition: RUNNING->SCHEDULAR_DISPATCH
  2025-05-12T19:35:28  [app] INVALID Transition: READY->IO_WAIT
```

* On demand FSM transition history can be fetched like this
```sh
std::stringstream outstream;
app_state.show_fsm_history(outstream);
cout << outstream.str() << endl;



app FSM History (currentTime: 2025-05-12T19:35:28) :-

0 2025-05-12T19:35:01 :: NEW->ADMITTED->READY
1 2025-05-12T19:35:13 :: READY->SCHEDULAR_DISPATCH->RUNNING
2 2025-05-12T19:35:18 :: RUNNING->IO_WAIT->WAITING
3 2025-05-12T19:35:22 :: WAITING->IO_COMPLETION->READY
```


### Build Requirement:
* g++ compiler (--stdc++11)
* cmake >= 2.8
* libxml2 (sudo apt-get install libxml2-dev libxml2-doc)

### Future Enhancement:
* please suggest

### Reference

* https://www.reddit.com/r/C_Programming/comments/1aw7erf/tools_for_generating_finite_state_machines/
* https://fsmgenerator.sourceforge.net/
* https://www.spiceworks.com/tech/tech-general/articles/what-is-fsm/
* https://gameprogrammingpatterns.com/state.html
